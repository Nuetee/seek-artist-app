{"version":3,"file":"usePopover.js","sources":["../../../../src/composables/usePopover.ts"],"sourcesContent":["import { computed, Ref, unref, watch } from 'vue'\n\nimport { mapObject } from '../utils/map-object'\nimport { useDomRect } from './useDomRect'\nimport { useClientOnly } from './useClientOnly'\n\nexport type PlacementPosition = 'top' | 'bottom' | 'left' | 'right'\nexport type PlacementAlignment = 'start' | 'end' | 'center'\nexport type Placement = PlacementPosition | 'auto' | `${PlacementPosition}-${PlacementAlignment}`\nexport type Offset = number | [number, number]\n\ntype Coords = { x: number, y: number }\ntype AlignCoords = { main: number, cross: number }\n\nexport const placementsPositions = ['top', 'bottom', 'left', 'right']\n  .reduce((acc, position) => [...acc, position, `${position}-start`, `${position}-end`, `${position}-center`], ['auto'] as string[])\n\nconst coordsToCss = ({ x, y }: Coords) => ({ left: `${x}px`, top: `${y}px` })\n\nconst parsePlacement = (placement: Placement) => {\n  const [position, align] = placement.split('-') as [PlacementPosition, PlacementAlignment | undefined]\n\n  return { position, align: align || 'center' }\n}\n\nconst parseOffset = (offset: Offset): AlignCoords => {\n  return Array.isArray(offset) ? { main: offset[0], cross: offset[1] } : { main: offset, cross: 0 }\n}\n\nconst calculateContentAlignment = (align: PlacementAlignment, anchorStart: number, anchorSize: number, contentSize: number) => {\n  if (align === 'start') { return anchorStart }\n  if (align === 'end') { return anchorStart + anchorSize - contentSize }\n\n  return anchorStart + (anchorSize - contentSize) / 2\n}\n\nconst calculateContentCoords = (placement: Placement, anchor: DOMRect, content: DOMRect) => {\n  const { position, align } = parsePlacement(placement)\n\n  const alignmentX = calculateContentAlignment(align, anchor.left, anchor.width, content.width)\n  const alignmentY = calculateContentAlignment(align, anchor.top, anchor.height, content.height)\n\n  switch (position) {\n    case 'top': return { x: alignmentX, y: anchor.top - content.height }\n    case 'left': return { y: alignmentY, x: anchor.left - content.width }\n    case 'right': return { y: alignmentY, x: anchor.right }\n    case 'bottom':\n    default: return { x: alignmentX, y: anchor.bottom }\n  }\n}\n\nconst calculateOffsetCoords = (placement: Placement, offset: Offset): Coords => {\n  const { position } = parsePlacement(placement)\n  const { main, cross } = parseOffset(offset)\n\n  switch (position) {\n    case 'left': return { y: cross, x: -main }\n    case 'right': return { y: cross, x: main }\n    case 'top': return { y: -main, x: cross }\n    case 'bottom':\n    default: return { y: main, x: cross }\n  }\n}\n\n/** Returns how much content overflow */\nconst calculateContentOverflow = (coords: Coords, content: DOMRect, root: DOMRect) => {\n  const xMax = root.right\n  const yMax = root.bottom\n  const xMin = root.left\n  const yMin = root.top\n\n  return {\n    top: Math.max(yMin - coords.y, 0),\n    bottom: Math.max((coords.y + content.height) - yMax, 0),\n    left: Math.max(xMin - coords.x, 0),\n    right: Math.max((coords.x + content.width) - xMax, 0),\n  }\n}\n\nconst clamp = (min: number, v: number, max: number) => Math.max(Math.min(v, max), min)\n\nconst calculateClipToEdge = (coords: Coords, offsetCoords: Coords, content: DOMRect, anchor: DOMRect, root: DOMRect) => {\n  const { top, bottom, left, right } = calculateContentOverflow(coords, content, root)\n\n  // Add left overflow, sub right overflow so content always stick to edge\n  const x = coords.x - right + left\n  const y = coords.y - bottom + top\n\n  const { x: offsetX, y: offsetY } = offsetCoords\n\n  return {\n    // Clamp content position near anchor, so any content edge should touch anchor edge\n    x: clamp(anchor.left + offsetX - content.width, x, anchor.right + offsetX),\n    y: clamp(anchor.top + offsetY - content.height, y, anchor.bottom + offsetY),\n  }\n}\n\nconst getAutoPlacement = (placement: Placement, coords: Coords, content: DOMRect, root: DOMRect): Placement => {\n  const { position, align } = parsePlacement(placement)\n  const overflow = calculateContentOverflow(coords, content, root)\n\n  const newPlacements = {\n    top: ['bottom', align].join('-') as Placement,\n    bottom: ['top', align].join('-') as Placement,\n    right: ['left', align].join('-') as Placement,\n    left: ['right', align].join('-') as Placement,\n  }\n\n  return overflow[position] ? newPlacements[position] : placement\n}\n\nexport type usePopoverOptions = {\n  keepAnchorWidth?: boolean,\n  autoPlacement?: boolean,\n  stickToEdges?: boolean,\n  placement: Placement,\n  offset?: Offset,\n  /** Root element selector */\n  root?: string\n}\n\n/**\n * Updates `contentRef` css, make it position fixed and moves relative to `anchorRef`\n * @param options make options reactive if you want popover to react on options change.\n */\nexport const usePopover = (\n  anchorRef: Ref<HTMLElement | undefined>,\n  contentRef: Ref<HTMLElement | undefined>,\n  options: usePopoverOptions | Ref<usePopoverOptions>,\n) => {\n  const documentRef = useClientOnly(() => document)\n  const rootRef = computed(() => {\n    if (!documentRef.value) { return undefined }\n\n    const { root } = unref(options)\n\n    if (root) { return documentRef.value.querySelector(root) }\n\n    return documentRef.value.body\n  })\n  const { domRect: anchorDomRect } = useDomRect(anchorRef)\n  const { domRect: contentDomRect } = useDomRect(contentRef)\n\n  const css = {\n    width: 'max-content',\n    position: 'absolute',\n  }\n\n  const updateContentCSS = () => {\n    if (!rootRef.value || !anchorDomRect.value || !contentDomRect.value) { return }\n\n    let offsetCoords: Coords = { x: 0, y: 0 }\n\n    const { placement, keepAnchorWidth, offset, autoPlacement, stickToEdges } = unref(options)\n\n    // calculate coords (x and y) of content left-top corner\n    let coords = calculateContentCoords(placement, anchorDomRect.value, contentDomRect.value)\n\n    if (offset) {\n      offsetCoords = calculateOffsetCoords(placement, offset)\n      coords = mapObject(coords, (c, key) => c + offsetCoords[key])\n    }\n\n    if (keepAnchorWidth) {\n      const { width } = anchorDomRect.value\n      Object.assign(css, { width: `${width}px`, maxWidth: `${width}px` })\n    }\n\n    const rootRect = rootRef.value.getBoundingClientRect()\n\n    if (autoPlacement) {\n      const newPlacement = getAutoPlacement(placement, coords, contentDomRect.value, rootRect)\n      if (newPlacement !== placement) {\n        coords = calculateContentCoords(newPlacement, anchorDomRect.value, contentDomRect.value)\n\n        if (offset) {\n          offsetCoords = calculateOffsetCoords(newPlacement, offset)\n          coords = mapObject(coords, (c, key) => c + offsetCoords[key])\n        }\n      }\n    }\n\n    if (stickToEdges) {\n      coords = calculateClipToEdge(coords, offsetCoords, contentDomRect.value, anchorDomRect.value, rootRect)\n    }\n\n    if (contentRef.value) {\n      Object.assign(contentRef.value.style, {\n        ...css,\n        ...coordsToCss(coords),\n      })\n    }\n  }\n\n  watch(anchorDomRect, updateContentCSS)\n  watch(contentDomRect, updateContentCSS)\n  watch(options, updateContentCSS, { deep: true })\n\n  return {\n    anchorDomRect,\n    contentDomRect,\n  }\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;AAca,MAAA,sBAAsB,CAAC,OAAO,UAAU,QAAQ,OAAO,EACjE,OAAO,CAAC,KAAK,aAAa,CAAC,GAAG,KAAK,UAAU,GAAG,kBAAkB,GAAG,gBAAgB,GAAG,iBAAiB,GAAG,CAAC,MAAM,CAAa;AAEnI,MAAM,cAAc,CAAC,EAAE,GAAG,QAAmB,GAAA,MAAM,GAAG,OAAO,KAAK,GAAG,MAAM;AAE3E,MAAM,iBAAiB,CAAC,cAAyB;AAC/C,QAAM,CAAC,UAAU,SAAS,UAAU,MAAM,GAAG;AAE7C,SAAO,EAAE,UAAU,OAAO,SAAS,SAAS;AAC9C;AAEA,MAAM,cAAc,CAAC,WAAgC;AACnD,SAAO,MAAM,QAAQ,MAAM,IAAI,EAAE,MAAM,OAAO,IAAI,OAAO,OAAO,OAAO,EAAE,MAAM,QAAQ,OAAO;AAChG;AAEA,MAAM,4BAA4B,CAAC,OAA2B,aAAqB,YAAoB,gBAAwB;AAC7H,MAAI,UAAU,SAAS;AAAS,WAAA;AAAA,EAAY;AAC5C,MAAI,UAAU,OAAO;AAAE,WAAO,cAAc,aAAa;AAAA,EAAY;AAE9D,SAAA,4BAA4B,eAAe;AACpD;AAEA,MAAM,yBAAyB,CAAC,WAAsB,QAAiB,YAAqB;AAC1F,QAAM,EAAE,UAAU,UAAU,eAAe,SAAS;AAE9C,QAAA,aAAa,0BAA0B,OAAO,OAAO,MAAM,OAAO,OAAO,QAAQ,KAAK;AACtF,QAAA,aAAa,0BAA0B,OAAO,OAAO,KAAK,OAAO,QAAQ,QAAQ,MAAM;AAErF,UAAA;AAAA,SACD;AAAO,aAAO,EAAE,GAAG,YAAY,GAAG,OAAO,MAAM,QAAQ;SACvD;AAAQ,aAAO,EAAE,GAAG,YAAY,GAAG,OAAO,OAAO,QAAQ;SACzD;AAAS,aAAO,EAAE,GAAG,YAAY,GAAG,OAAO,MAAM;AAAA,SACjD;AAAA;AACI,aAAO,EAAE,GAAG,YAAY,GAAG,OAAO,OAAO;AAAA;AAEtD;AAEA,MAAM,wBAAwB,CAAC,WAAsB,WAA2B;AACxE,QAAA,EAAE,aAAa,eAAe,SAAS;AAC7C,QAAM,EAAE,MAAM,UAAU,YAAY,MAAM;AAElC,UAAA;AAAA,SACD;AAAQ,aAAO,EAAE,GAAG,OAAO,GAAG,CAAC,KAAK;AAAA,SACpC;AAAS,aAAO,EAAE,GAAG,OAAO,GAAG,KAAK;AAAA,SACpC;AAAO,aAAO,EAAE,GAAG,CAAC,MAAM,GAAG,MAAM;AAAA,SACnC;AAAA;AACI,aAAO,EAAE,GAAG,MAAM,GAAG,MAAM;AAAA;AAExC;AAGA,MAAM,2BAA2B,CAAC,QAAgB,SAAkB,SAAkB;AACpF,QAAM,OAAO,KAAK;AAClB,QAAM,OAAO,KAAK;AAClB,QAAM,OAAO,KAAK;AAClB,QAAM,OAAO,KAAK;AAEX,SAAA;AAAA,IACL,KAAK,KAAK,IAAI,OAAO,OAAO,GAAG,CAAC;AAAA,IAChC,QAAQ,KAAK,IAAK,OAAO,IAAI,QAAQ,SAAU,MAAM,CAAC;AAAA,IACtD,MAAM,KAAK,IAAI,OAAO,OAAO,GAAG,CAAC;AAAA,IACjC,OAAO,KAAK,IAAK,OAAO,IAAI,QAAQ,QAAS,MAAM,CAAC;AAAA,EAAA;AAExD;AAEA,MAAM,QAAQ,CAAC,KAAa,GAAW,QAAgB,KAAK,IAAI,KAAK,IAAI,GAAG,GAAG,GAAG,GAAG;AAErF,MAAM,sBAAsB,CAAC,QAAgB,cAAsB,SAAkB,QAAiB,SAAkB;AAChH,QAAA,EAAE,KAAK,QAAQ,MAAM,UAAU,yBAAyB,QAAQ,SAAS,IAAI;AAG7E,QAAA,IAAI,OAAO,IAAI,QAAQ;AACvB,QAAA,IAAI,OAAO,IAAI,SAAS;AAE9B,QAAM,EAAE,GAAG,SAAS,GAAG,YAAY;AAE5B,SAAA;AAAA,IAEL,GAAG,MAAM,OAAO,OAAO,UAAU,QAAQ,OAAO,GAAG,OAAO,QAAQ,OAAO;AAAA,IACzE,GAAG,MAAM,OAAO,MAAM,UAAU,QAAQ,QAAQ,GAAG,OAAO,SAAS,OAAO;AAAA,EAAA;AAE9E;AAEA,MAAM,mBAAmB,CAAC,WAAsB,QAAgB,SAAkB,SAA6B;AAC7G,QAAM,EAAE,UAAU,UAAU,eAAe,SAAS;AACpD,QAAM,WAAW,yBAAyB,QAAQ,SAAS,IAAI;AAE/D,QAAM,gBAAgB;AAAA,IACpB,KAAK,CAAC,UAAU,KAAK,EAAE,KAAK,GAAG;AAAA,IAC/B,QAAQ,CAAC,OAAO,KAAK,EAAE,KAAK,GAAG;AAAA,IAC/B,OAAO,CAAC,QAAQ,KAAK,EAAE,KAAK,GAAG;AAAA,IAC/B,MAAM,CAAC,SAAS,KAAK,EAAE,KAAK,GAAG;AAAA,EAAA;AAG1B,SAAA,SAAS,YAAY,cAAc,YAAY;AACxD;AAgBO,MAAM,aAAa,CACxB,WACA,YACA,YACG;AACG,QAAA,cAAc,cAAc,MAAM,QAAQ;AAC1C,QAAA,UAAU,SAAS,MAAM;AACzB,QAAA,CAAC,YAAY,OAAO;AAAS,aAAA;AAAA,IAAU;AAErC,UAAA,EAAE,SAAS,MAAM,OAAO;AAE9B,QAAI,MAAM;AAAS,aAAA,YAAY,MAAM,cAAc,IAAI;AAAA,IAAE;AAEzD,WAAO,YAAY,MAAM;AAAA,EAAA,CAC1B;AACD,QAAM,EAAE,SAAS,kBAAkB,WAAW,SAAS;AACvD,QAAM,EAAE,SAAS,mBAAmB,WAAW,UAAU;AAEzD,QAAM,MAAM;AAAA,IACV,OAAO;AAAA,IACP,UAAU;AAAA,EAAA;AAGZ,QAAM,mBAAmB,MAAM;AACzB,QAAA,CAAC,QAAQ,SAAS,CAAC,cAAc,SAAS,CAAC,eAAe,OAAO;AAAE;AAAA,IAAO;AAE9E,QAAI,eAAuB,EAAE,GAAG,GAAG,GAAG,EAAE;AAExC,UAAM,EAAE,WAAW,iBAAiB,QAAQ,eAAe,iBAAiB,MAAM,OAAO;AAGzF,QAAI,SAAS,uBAAuB,WAAW,cAAc,OAAO,eAAe,KAAK;AAExF,QAAI,QAAQ;AACK,qBAAA,sBAAsB,WAAW,MAAM;AACtD,eAAS,UAAU,QAAQ,CAAC,GAAG,QAAQ,IAAI,aAAa,IAAI;AAAA,IAC9D;AAEA,QAAI,iBAAiB;AACb,YAAA,EAAE,UAAU,cAAc;AACzB,aAAA,OAAO,KAAK,EAAE,OAAO,GAAG,WAAW,UAAU,GAAG,UAAW,CAAA;AAAA,IACpE;AAEM,UAAA,WAAW,QAAQ,MAAM,sBAAsB;AAErD,QAAI,eAAe;AACjB,YAAM,eAAe,iBAAiB,WAAW,QAAQ,eAAe,OAAO,QAAQ;AACvF,UAAI,iBAAiB,WAAW;AAC9B,iBAAS,uBAAuB,cAAc,cAAc,OAAO,eAAe,KAAK;AAEvF,YAAI,QAAQ;AACK,yBAAA,sBAAsB,cAAc,MAAM;AACzD,mBAAS,UAAU,QAAQ,CAAC,GAAG,QAAQ,IAAI,aAAa,IAAI;AAAA,QAC9D;AAAA,MACF;AAAA,IACF;AAEA,QAAI,cAAc;AAChB,eAAS,oBAAoB,QAAQ,cAAc,eAAe,OAAO,cAAc,OAAO,QAAQ;AAAA,IACxG;AAEA,QAAI,WAAW,OAAO;AACb,aAAA,OAAO,WAAW,MAAM,OAAO,kCACjC,MACA,YAAY,MAAM,EACtB;AAAA,IACH;AAAA,EAAA;AAGF,QAAM,eAAe,gBAAgB;AACrC,QAAM,gBAAgB,gBAAgB;AACtC,QAAM,SAAS,kBAAkB,EAAE,MAAM,KAAM,CAAA;AAExC,SAAA;AAAA,IACL;AAAA,IACA;AAAA,EAAA;AAEJ;;"}