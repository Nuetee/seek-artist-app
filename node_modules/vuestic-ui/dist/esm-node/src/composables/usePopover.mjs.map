{"version":3,"file":"usePopover.mjs","sources":["../../../../src/composables/usePopover.ts"],"sourcesContent":["import { computed, Ref, unref, watch } from 'vue'\n\nimport { mapObject } from '../utils/map-object'\nimport { useDomRect } from './useDomRect'\nimport { useClientOnly } from './useClientOnly'\n\nexport type PlacementPosition = 'top' | 'bottom' | 'left' | 'right'\nexport type PlacementAlignment = 'start' | 'end' | 'center'\nexport type Placement = PlacementPosition | 'auto' | `${PlacementPosition}-${PlacementAlignment}`\nexport type Offset = number | [number, number]\n\ntype Coords = { x: number, y: number }\ntype AlignCoords = { main: number, cross: number }\n\nexport const placementsPositions = ['top', 'bottom', 'left', 'right']\n  .reduce((acc, position) => [...acc, position, `${position}-start`, `${position}-end`, `${position}-center`], ['auto'] as string[])\n\nconst coordsToCss = ({ x, y }: Coords) => ({ left: `${x}px`, top: `${y}px` })\n\nconst parsePlacement = (placement: Placement) => {\n  const [position, align] = placement.split('-') as [PlacementPosition, PlacementAlignment | undefined]\n\n  return { position, align: align || 'center' }\n}\n\nconst parseOffset = (offset: Offset): AlignCoords => {\n  return Array.isArray(offset) ? { main: offset[0], cross: offset[1] } : { main: offset, cross: 0 }\n}\n\nconst calculateContentAlignment = (align: PlacementAlignment, anchorStart: number, anchorSize: number, contentSize: number) => {\n  if (align === 'start') { return anchorStart }\n  if (align === 'end') { return anchorStart + anchorSize - contentSize }\n\n  return anchorStart + (anchorSize - contentSize) / 2\n}\n\nconst calculateContentCoords = (placement: Placement, anchor: DOMRect, content: DOMRect) => {\n  const { position, align } = parsePlacement(placement)\n\n  const alignmentX = calculateContentAlignment(align, anchor.left, anchor.width, content.width)\n  const alignmentY = calculateContentAlignment(align, anchor.top, anchor.height, content.height)\n\n  switch (position) {\n    case 'top': return { x: alignmentX, y: anchor.top - content.height }\n    case 'left': return { y: alignmentY, x: anchor.left - content.width }\n    case 'right': return { y: alignmentY, x: anchor.right }\n    case 'bottom':\n    default: return { x: alignmentX, y: anchor.bottom }\n  }\n}\n\nconst calculateOffsetCoords = (placement: Placement, offset: Offset): Coords => {\n  const { position } = parsePlacement(placement)\n  const { main, cross } = parseOffset(offset)\n\n  switch (position) {\n    case 'left': return { y: cross, x: -main }\n    case 'right': return { y: cross, x: main }\n    case 'top': return { y: -main, x: cross }\n    case 'bottom':\n    default: return { y: main, x: cross }\n  }\n}\n\n/** Returns how much content overflow */\nconst calculateContentOverflow = (coords: Coords, content: DOMRect, root: DOMRect) => {\n  const xMax = root.right\n  const yMax = root.bottom\n  const xMin = root.left\n  const yMin = root.top\n\n  return {\n    top: Math.max(yMin - coords.y, 0),\n    bottom: Math.max((coords.y + content.height) - yMax, 0),\n    left: Math.max(xMin - coords.x, 0),\n    right: Math.max((coords.x + content.width) - xMax, 0),\n  }\n}\n\nconst clamp = (min: number, v: number, max: number) => Math.max(Math.min(v, max), min)\n\nconst calculateClipToEdge = (coords: Coords, offsetCoords: Coords, content: DOMRect, anchor: DOMRect, root: DOMRect) => {\n  const { top, bottom, left, right } = calculateContentOverflow(coords, content, root)\n\n  // Add left overflow, sub right overflow so content always stick to edge\n  const x = coords.x - right + left\n  const y = coords.y - bottom + top\n\n  const { x: offsetX, y: offsetY } = offsetCoords\n\n  return {\n    // Clamp content position near anchor, so any content edge should touch anchor edge\n    x: clamp(anchor.left + offsetX - content.width, x, anchor.right + offsetX),\n    y: clamp(anchor.top + offsetY - content.height, y, anchor.bottom + offsetY),\n  }\n}\n\nconst getAutoPlacement = (placement: Placement, coords: Coords, content: DOMRect, root: DOMRect): Placement => {\n  const { position, align } = parsePlacement(placement)\n  const overflow = calculateContentOverflow(coords, content, root)\n\n  const newPlacements = {\n    top: ['bottom', align].join('-') as Placement,\n    bottom: ['top', align].join('-') as Placement,\n    right: ['left', align].join('-') as Placement,\n    left: ['right', align].join('-') as Placement,\n  }\n\n  return overflow[position] ? newPlacements[position] : placement\n}\n\nexport type usePopoverOptions = {\n  keepAnchorWidth?: boolean,\n  autoPlacement?: boolean,\n  stickToEdges?: boolean,\n  placement: Placement,\n  offset?: Offset,\n  /** Root element selector */\n  root?: string\n}\n\n/**\n * Updates `contentRef` css, make it position fixed and moves relative to `anchorRef`\n * @param options make options reactive if you want popover to react on options change.\n */\nexport const usePopover = (\n  anchorRef: Ref<HTMLElement | undefined>,\n  contentRef: Ref<HTMLElement | undefined>,\n  options: usePopoverOptions | Ref<usePopoverOptions>,\n) => {\n  const documentRef = useClientOnly(() => document)\n  const rootRef = computed(() => {\n    if (!documentRef.value) { return undefined }\n\n    const { root } = unref(options)\n\n    if (root) { return documentRef.value.querySelector(root) }\n\n    return documentRef.value.body\n  })\n  const { domRect: anchorDomRect } = useDomRect(anchorRef)\n  const { domRect: contentDomRect } = useDomRect(contentRef)\n\n  const css = {\n    width: 'max-content',\n    position: 'absolute',\n  }\n\n  const updateContentCSS = () => {\n    if (!rootRef.value || !anchorDomRect.value || !contentDomRect.value) { return }\n\n    let offsetCoords: Coords = { x: 0, y: 0 }\n\n    const { placement, keepAnchorWidth, offset, autoPlacement, stickToEdges } = unref(options)\n\n    // calculate coords (x and y) of content left-top corner\n    let coords = calculateContentCoords(placement, anchorDomRect.value, contentDomRect.value)\n\n    if (offset) {\n      offsetCoords = calculateOffsetCoords(placement, offset)\n      coords = mapObject(coords, (c, key) => c + offsetCoords[key])\n    }\n\n    if (keepAnchorWidth) {\n      const { width } = anchorDomRect.value\n      Object.assign(css, { width: `${width}px`, maxWidth: `${width}px` })\n    }\n\n    const rootRect = rootRef.value.getBoundingClientRect()\n\n    if (autoPlacement) {\n      const newPlacement = getAutoPlacement(placement, coords, contentDomRect.value, rootRect)\n      if (newPlacement !== placement) {\n        coords = calculateContentCoords(newPlacement, anchorDomRect.value, contentDomRect.value)\n\n        if (offset) {\n          offsetCoords = calculateOffsetCoords(newPlacement, offset)\n          coords = mapObject(coords, (c, key) => c + offsetCoords[key])\n        }\n      }\n    }\n\n    if (stickToEdges) {\n      coords = calculateClipToEdge(coords, offsetCoords, contentDomRect.value, anchorDomRect.value, rootRect)\n    }\n\n    if (contentRef.value) {\n      Object.assign(contentRef.value.style, {\n        ...css,\n        ...coordsToCss(coords),\n      })\n    }\n  }\n\n  watch(anchorDomRect, updateContentCSS)\n  watch(contentDomRect, updateContentCSS)\n  watch(options, updateContentCSS, { deep: true })\n\n  return {\n    anchorDomRect,\n    contentDomRect,\n  }\n}\n"],"names":["placementsPositions","reduce","acc","position","parsePlacement","placement","align","split","calculateContentAlignment","anchorStart","anchorSize","contentSize","calculateContentCoords","anchor","content","alignmentX","left","width","alignmentY","top","height","x","y","right","bottom","calculateOffsetCoords","offset","main","cross","Array","isArray","parseOffset","calculateContentOverflow","coords","root","xMax","yMax","xMin","yMin","Math","max","clamp","min","v","usePopover","anchorRef","contentRef","options","documentRef","useClientOnly","document","rootRef","computed","value","unref","querySelector","body","domRect","anchorDomRect","useDomRect","contentDomRect","css","updateContentCSS","offsetCoords","keepAnchorWidth","autoPlacement","stickToEdges","mapObject","c","key","Object","assign","maxWidth","rootRect","getBoundingClientRect","newPlacement","overflow","newPlacements","join","getAutoPlacement","offsetX","offsetY","calculateClipToEdge","style","__spreadValues","coordsToCss","watch","deep"],"mappings":"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"}